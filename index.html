<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SWE-bench-Live Leaderboard</title>
  <link rel="icon" type="image/png" href="assets/swe-bench-live.png">
  <link rel="stylesheet" href="style.css" />
  <!-- Import Inter font from Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="title">
        <img src="assets/swe-bench-live.png" alt="SWE-bench-Live Logo" class="logo"/>
        <h1>SWE-bench-Live Leaderboard</h1>
      </div>
      <p class="subtitle">Evaluating your AI system on latest software engineering tasks.</p>
    </div>

    <!-- Navigation buttons -->
    <div class="nav-buttons">
      <a href="https://arxiv.org/abs/2505.23419" class="btn btn-paper">Paper</a>
      <a href="https://github.com/microsoft/SWE-bench-Live" class="btn btn-github">
        <img src="assets/github.svg" alt="GitHub" class="btn-icon">
        GitHub
      </a>
      <a href="https://huggingface.co/swe-bench-live" class="btn btn-huggingface">
        <img src="assets/huggingface.svg" alt="HuggingFace" class="btn-icon">
        HuggingFace
      </a>
    </div>

    <div class="leaderboard-container">
      <div class="table-header">
        <div class="header-left">
          <div class="stats">
            <span id="total-models">Loading...</span> methods evaluated on <span id="current-set">Lite</span> set
          </div>
        </div>
        <!-- Dataset selection tabs -->
        <div class="dataset-tabs">
          <button class="tab-btn active" data-set="lite">Lite</button>
          <button class="tab-btn" data-set="full">Full</button>
        </div>
      </div>
      
      <div class="table-wrapper">
        <table class="leaderboard-table" id="leaderboard">
          <thead>
            <tr>
              <th class="rank-col">#</th>
              <th class="model-col">Model</th>
              <th class="metric-col sortable" data-sort="resolved">
                <span class="header-text">% Resolved</span>
                <span class="sort-arrow">↕</span>
              </th>
              <th class="metric-col sortable" data-sort="applied">
                <span class="header-text">% Applied</span>
                <span class="sort-arrow">↕</span>
              </th>
              <th class="metric-col sortable" data-sort="loc_suc">
                <span class="header-text">% Loc Success</span>
                <span class="sort-arrow">↕</span>
              </th>
              <th class="date-col sortable" data-sort="date">
                <span class="header-text">Date</span>
                <span class="sort-arrow">↕</span>
              </th>
            </tr>
          </thead>
          <tbody id="leaderboard-body">
            <!-- Data will be populated by JavaScript -->
          </tbody>
        </table>
      </div>
      
      <div class="loading" id="loading">
        <div class="spinner"></div>
        <p>Loading leaderboard data...</p>
      </div>
      
      <div class="error" id="error" style="display: none;">
        <p>Error loading data. Please try again later.</p>
      </div>
    </div>

    <!-- Instance Analysis Section -->
    <div class="analysis-controls">
      <div class="controls-header">
        <p>Select a time range and method to analyze solved/unsolved instances</p>
      </div>
      
      <div class="controls-content">
        <div class="control-group">
          <label for="method-select">Method (full set only):</label>
          <select id="method-select" class="method-select">
            <option value="">Select a method...</option>
          </select>
        </div>
        
        <div class="control-group">
          <label>Time Range:</label>
          <div class="time-range-container">
            <div class="time-range-slider">
              <div class="slider-track"></div>
              <div class="slider-range" id="slider-range"></div>
              <input type="range" id="start-slider" class="range-input" min="0" max="16" value="0" step="1">
              <input type="range" id="end-slider" class="range-input" min="0" max="16" value="16" step="1">
            </div>
            <div class="time-labels">
              <span id="start-label">Jan 2024</span>
              <span id="end-label">Apr 2025</span>
            </div>
          </div>
        </div>
        
        <button id="analyze-btn" class="analyze-btn" disabled>Analyze</button>
      </div>
      
      <div class="analysis-results" id="analysis-results" style="display: none;">
        <div class="results-header">
          <h4>Analysis Results</h4>
          <div class="results-stats">
            <div class="stat-item">
              <span class="stat-label">Time Range:</span>
              <span class="stat-value" id="selected-range">-</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Total Instances:</span>
              <span class="stat-value" id="total-instances">-</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Resolved Rate:</span>
              <span class="stat-value" id="resolved-rate">-</span>
            </div>
          </div>
        </div>
        
        <div class="results-content">
          <div class="instance-section">
            <h5>Solved Instances (<span id="solved-count">0</span>)</h5>
            <div class="instance-list" id="solved-instances"></div>
          </div>
          
          <div class="instance-section">
            <h5>Unsolved Instances (<span id="unsolved-count">0</span>)</h5>
            <div class="instance-list" id="unsolved-instances"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="statement">
      <h3>Submit your results</h3>
      <p>
        We coordinate results submission via Pull Requests, see <a href="https://github.com/swe-bench-live/submission" target="_blank">SWE-bench-Live/submissions</a> for instructions.
      </p>
    </div>

    <!-- Acknowledgement section -->
    <div class="statement">
      <h3>Acknowledgement</h3>
      <p>
        SWE-bench-Live is built upon the foundation of <a href="https://www.swebench.com/" target="_blank">SWE-bench</a>.
        We extend our gratitude to the original SWE-bench team for their pioneering work in software engineering evaluation benchmarks.
      </p>
    </div>

    <div class="statement">
      <h3>Citation</h3>
      <p>
        If you use SWE-bench-Live in your research, please cite:
        <pre>
@article{zhang2025swebenchgoeslive,
  title={SWE-bench Goes Live!},
  author={Linghao Zhang and Shilin He and Chaoyun Zhang and Yu Kang and Bowen Li and Chengxing Xie and Junhao Wang and Maoquan Wang and Yufan Huang and Shengyu Fu and Elsie Nallipogu and Qingwei Lin and Yingnong Dang and Saravan Rajmohan and Dongmei Zhang},
  journal={arXiv preprint arXiv:2505.23419},
  year={2025}
}</pre>
      </p>
    </div>
  </div>

  <script>
    // Logo mapping for different organizations
    const logoMap = {
      'swe-agent': 'assets/logos/swe-agent.png',
      'openhands': 'assets/logos/openhands.png',
      'agentless': 'assets/logos/agentless.png'
    };

    // Current sort configuration
    let currentSort = { column: 'resolved', direction: 'desc' };
    let currentDataset = 'lite';
    let datasetInstances = [];
    let allReports = [];

    // Time range mapping (months from Jan 2024 to Apr 2025)
    const timeRangeMap = [
      { label: 'Jan 2024', year: 2024, month: 1 },
      { label: 'Feb 2024', year: 2024, month: 2 },
      { label: 'Mar 2024', year: 2024, month: 3 },
      { label: 'Apr 2024', year: 2024, month: 4 },
      { label: 'May 2024', year: 2024, month: 5 },
      { label: 'Jun 2024', year: 2024, month: 6 },
      { label: 'Jul 2024', year: 2024, month: 7 },
      { label: 'Aug 2024', year: 2024, month: 8 },
      { label: 'Sep 2024', year: 2024, month: 9 },
      { label: 'Oct 2024', year: 2024, month: 10 },
      { label: 'Nov 2024', year: 2024, month: 11 },
      { label: 'Dec 2024', year: 2024, month: 12 },
      { label: 'Jan 2025', year: 2025, month: 1 },
      { label: 'Feb 2025', year: 2025, month: 2 },
      { label: 'Mar 2025', year: 2025, month: 3 },
      { label: 'Apr 2025', year: 2025, month: 4 },
      { label: 'May 2025', year: 2025, month: 5 }
    ];

    // Load dataset instances
    async function loadDatasetInstances() {
      try {
        const response = await fetch('dataset.jsonl');
        const text = await response.text();
        const lines = text.trim().split('\n').filter(line => line.trim());
        datasetInstances = lines.map(line => JSON.parse(line));
      } catch (error) {
        console.error('Error loading dataset instances:', error);
      }
    }

    // Load and display leaderboard data
    async function loadLeaderboard() {
      try {
        const response = await fetch('reports.jsonl');
        const text = await response.text();
        
        // Parse JSONL format
        const lines = text.trim().split('\n').filter(line => line.trim());
        allReports = lines.map(line => JSON.parse(line));
        
        // Filter by current dataset
        const data = allReports.filter(item => item.set === currentDataset);
        
        // Sort by current sort configuration
        sortData(data, currentSort.column, currentSort.direction);
        
        displayLeaderboard(data);
        document.getElementById('total-models').textContent = data.length;
        document.getElementById('current-set').textContent = currentDataset.charAt(0).toUpperCase() + currentDataset.slice(1);
        document.getElementById('loading').style.display = 'none';
        
        // Populate method selector for analysis
        populateMethodSelector();
        
      } catch (error) {
        console.error('Error loading leaderboard:', error);
        document.getElementById('loading').style.display = 'none';
        document.getElementById('error').style.display = 'block';
      }
    }

    // Populate method selector with full dataset methods
    function populateMethodSelector() {
      const methodSelect = document.getElementById('method-select');
      const fullMethods = allReports.filter(item => item.set === 'full');
      
      // Clear existing options except the first one
      methodSelect.innerHTML = '<option value="">Select a method...</option>';
      
      fullMethods.forEach(method => {
        const option = document.createElement('option');
        option.value = method.name;
        option.textContent = method.name;
        methodSelect.appendChild(option);
      });
    }

    // Sort data by column
    function sortData(data, column, direction) {
      data.sort((a, b) => {
        let aVal, bVal;
        
        if (column === 'date') {
          aVal = new Date(a[column]);
          bVal = new Date(b[column]);
        } else if (column === 'resolved' || column === 'applied' || column === 'loc_suc') {
          aVal = parseFloat(a[column]);
          bVal = parseFloat(b[column]);
        } else {
          aVal = a[column].toLowerCase();
          bVal = b[column].toLowerCase();
        }
        
        if (direction === 'asc') {
          return aVal > bVal ? 1 : -1;
        } else {
          return aVal < bVal ? 1 : -1;
        }
      });
    }

    // Display leaderboard data
    function displayLeaderboard(data) {
      const tbody = document.getElementById('leaderboard-body');
      tbody.innerHTML = '';
      
      if (data.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td colspan="6" style="text-align: center; padding: 3rem; color: #64748b;">
            <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">📊</div>
            <div>No results available for ${currentDataset.charAt(0).toUpperCase() + currentDataset.slice(1)} dataset</div>
            <div style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 0.8;">Please check back later or try a different dataset</div>
          </td>
        `;
        tbody.appendChild(row);
        return;
      }
      
      data.forEach((item, index) => {
        const row = document.createElement('tr');
        
        // Add rank badge for top 3
        let rankBadge = '';
        if (index === 0) rankBadge = '<span class="rank-badge gold">🥇</span>';
        else if (index === 1) rankBadge = '<span class="rank-badge silver">🥈</span>';
        else if (index === 2) rankBadge = '<span class="rank-badge bronze">🥉</span>';
        
        const logoSrc = logoMap[item.logo] || 'assets/logos/swe-agent.png';
        const formattedDate = new Date(item.date).toLocaleDateString('en-US', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit'
        });
        
        row.innerHTML = `
          <td class="rank-col">${rankBadge}${index + 1}</td>
          <td class="model-col">
            <div class="model-info">
              <div class="model-logo-frame">
                <img src="${logoSrc}" alt="${item.logo}" class="model-logo-img">
              </div>
              <span class="model-name">${item.name}</span>
            </div>
          </td>
          <td class="metric-col">
            <div class="metric-value">
              <span class="percentage">${item.resolved}%</span>
              <div class="progress-bar">
                <div class="progress-fill" style="width: ${item.resolved}%"></div>
              </div>
            </div>
          </td>
          <td class="metric-col">
            <div class="metric-value">
              <span class="percentage">${item.applied}%</span>
              <div class="progress-bar">
                <div class="progress-fill" style="width: ${item.applied}%"></div>
              </div>
            </div>
          </td>
          <td class="metric-col">
            <div class="metric-value">
              <span class="percentage">${item.loc_suc}%</span>
              <div class="progress-bar">
                <div class="progress-fill" style="width: ${item.loc_suc}%"></div>
              </div>
            </div>
          </td>
          <td class="date-col">${formattedDate}</td>
        `;
        
        tbody.appendChild(row);
      });
    }

    // Handle column sorting
    function setupSorting() {
      const sortableHeaders = document.querySelectorAll('.sortable');
      
      sortableHeaders.forEach(header => {
        header.addEventListener('click', () => {
          const column = header.dataset.sort;
          let direction = 'desc';
          
          // Toggle direction if clicking the same column
          if (currentSort.column === column) {
            direction = currentSort.direction === 'desc' ? 'asc' : 'desc';
          }
          
          currentSort = { column, direction };
          
          // Update sort arrows
          sortableHeaders.forEach(h => {
            const arrow = h.querySelector('.sort-arrow');
            arrow.textContent = '↕';
            h.classList.remove('sorted-asc', 'sorted-desc');
          });
          
          const arrow = header.querySelector('.sort-arrow');
          arrow.textContent = direction === 'desc' ? '↓' : '↑';
          header.classList.add(direction === 'desc' ? 'sorted-desc' : 'sorted-asc');
          
          // Re-load and sort data
          loadLeaderboard();
        });
      });
    }

    // Handle dataset tab switching
    function setupDatasetTabs() {
      const tabButtons = document.querySelectorAll('.tab-btn');
      
      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          // Update active tab
          tabButtons.forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
          
          // Update current dataset
          currentDataset = button.dataset.set;
          
          // Show loading and reload data
          document.getElementById('loading').style.display = 'block';
          document.getElementById('error').style.display = 'none';
          loadLeaderboard();
        });
      });
    }

    // Setup time range slider
    function setupTimeRangeSlider() {
      const startSlider = document.getElementById('start-slider');
      const endSlider = document.getElementById('end-slider');
      const startLabel = document.getElementById('start-label');
      const endLabel = document.getElementById('end-label');
      const sliderRange = document.getElementById('slider-range');
      
      function updateSlider() {
        const startVal = parseInt(startSlider.value);
        const endVal = parseInt(endSlider.value);
        
        // Ensure start is always less than or equal to end
        if (startVal > endVal) {
          if (this === startSlider) {
            endSlider.value = startVal;
          } else {
            startSlider.value = endVal;
          }
        }
        
        const finalStart = Math.min(parseInt(startSlider.value), parseInt(endSlider.value));
        const finalEnd = Math.max(parseInt(startSlider.value), parseInt(endSlider.value));
        
        startLabel.textContent = timeRangeMap[finalStart].label;
        endLabel.textContent = timeRangeMap[finalEnd].label;
        
        // Update visual range
        const percent1 = (finalStart / 16) * 100;
        const percent2 = (finalEnd / 16) * 100;
        sliderRange.style.left = percent1 + '%';
        sliderRange.style.width = (percent2 - percent1) + '%';
        
        // Enable/disable analyze button
        const methodSelect = document.getElementById('method-select');
        const analyzeBtn = document.getElementById('analyze-btn');
        analyzeBtn.disabled = !methodSelect.value;
      }
      
      startSlider.addEventListener('input', updateSlider);
      endSlider.addEventListener('input', updateSlider);
      
      // Initial update
      updateSlider();
    }

    // Setup method selection
    function setupMethodSelection() {
      const methodSelect = document.getElementById('method-select');
      const analyzeBtn = document.getElementById('analyze-btn');
      
      methodSelect.addEventListener('change', () => {
        analyzeBtn.disabled = !methodSelect.value;
      });
    }

    // Setup analysis functionality
    function setupAnalysis() {
      const analyzeBtn = document.getElementById('analyze-btn');
      
      analyzeBtn.addEventListener('click', () => {
        performAnalysis();
      });
    }

    // Perform instance analysis
    function performAnalysis() {
      const methodSelect = document.getElementById('method-select');
      const startSlider = document.getElementById('start-slider');
      const endSlider = document.getElementById('end-slider');
      
      const selectedMethod = methodSelect.value;
      const startIndex = Math.min(parseInt(startSlider.value), parseInt(endSlider.value));
      const endIndex = Math.max(parseInt(startSlider.value), parseInt(endSlider.value));
      
      const startTime = timeRangeMap[startIndex];
      const endTime = timeRangeMap[endIndex];
      
      // Find the method data
      const methodData = allReports.find(report => report.name === selectedMethod && report.set === 'full');
      if (!methodData) {
        alert('Method data not found');
        return;
      }
      
      // Filter instances by time range
      const filteredInstances = datasetInstances.filter(instance => {
        const createdDate = new Date(instance.created_at);
        const createdYear = createdDate.getFullYear();
        const createdMonth = createdDate.getMonth() + 1; // getMonth() returns 0-11
        
        // Check if the instance falls within the selected time range
        const startDate = new Date(startTime.year, startTime.month - 1, 1);
        const endDate = new Date(endTime.year, endTime.month, 0); // Last day of end month
        
        return createdDate >= startDate && createdDate <= endDate;
      });
      
      // Separate solved and unsolved instances
      const solvedInstances = filteredInstances.filter(instance => 
        methodData.resolved_ids.includes(instance.instance_id)
      );
      const unsolvedInstances = filteredInstances.filter(instance => 
        !methodData.resolved_ids.includes(instance.instance_id)
      );
      
      // Calculate resolved rate
      const resolvedRate = filteredInstances.length > 0 
        ? ((solvedInstances.length / filteredInstances.length) * 100).toFixed(2)
        : '0.00';
      
      // Display results
      displayAnalysisResults({
        timeRange: `${startTime.label} - ${endTime.label}`,
        totalInstances: filteredInstances.length,
        resolvedRate: resolvedRate,
        solvedInstances: solvedInstances,
        unsolvedInstances: unsolvedInstances
      });
    }

    // Display analysis results
    function displayAnalysisResults(results) {
      document.getElementById('selected-range').textContent = results.timeRange;
      document.getElementById('total-instances').textContent = results.totalInstances;
      document.getElementById('resolved-rate').textContent = results.resolvedRate + '%';
      document.getElementById('solved-count').textContent = results.solvedInstances.length;
      document.getElementById('unsolved-count').textContent = results.unsolvedInstances.length;
      
      // Display solved instances
      const solvedContainer = document.getElementById('solved-instances');
      solvedContainer.innerHTML = '';
      results.solvedInstances.forEach(instance => {
        const link = createInstanceLink(instance);
        solvedContainer.appendChild(link);
      });
      
      // Display unsolved instances
      const unsolvedContainer = document.getElementById('unsolved-instances');
      unsolvedContainer.innerHTML = '';
      results.unsolvedInstances.forEach(instance => {
        const link = createInstanceLink(instance);
        unsolvedContainer.appendChild(link);
      });
      
      // Show results
      document.getElementById('analysis-results').style.display = 'block';
    }

    // Create instance link with date
    function createInstanceLink(instance) {
      const container = document.createElement('div');
      container.className = 'instance-item';
      
      const link = document.createElement('a');
      link.href = `https://github.com/${instance.repo}/pull/${instance.instance_id.split('__').pop().split('-').pop()}`;
      link.target = '_blank';
      link.className = 'instance-link';
      link.textContent = instance.instance_id;
      
      const date = document.createElement('span');
      date.className = 'instance-date';
      const createdDate = new Date(instance.created_at);
      date.textContent = createdDate.toLocaleDateString('en-US', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit'
      });
      
      container.appendChild(link);
      container.appendChild(date);
      return container;
    }

    // Initialize the page
    document.addEventListener('DOMContentLoaded', async () => {
      setupSorting();
      setupDatasetTabs();
      setupTimeRangeSlider();
      setupMethodSelection();
      setupAnalysis();
      
      // Load data
      await loadDatasetInstances();
      await loadLeaderboard();
    });
  </script>
</body>
</html>